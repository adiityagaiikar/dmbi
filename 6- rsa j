import java.math.BigInteger;
import java.security.SecureRandom;

public class RSAKeyGenerator {

    public static boolean isProbablePrime(BigInteger n, int k) {
        if (n.compareTo(BigInteger.TWO) < 0)
            return false;

        int[] smallPrimes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
        for (int p : smallPrimes) {
            BigInteger bp = BigInteger.valueOf(p);
            if (n.mod(bp).equals(BigInteger.ZERO))
                return n.equals(bp);
        }

        BigInteger d = n.subtract(BigInteger.ONE);
        int s = 0;
        while (d.mod(BigInteger.TWO).equals(BigInteger.ZERO)) {
            d = d.divide(BigInteger.TWO);
            s++;
        }

        SecureRandom rand = new SecureRandom();
        for (int i = 0; i < k; i++) {
            BigInteger a;
            do {
                a = new BigInteger(n.bitLength(), rand);
            } while (a.compareTo(BigInteger.TWO) < 0 || a.compareTo(n.subtract(BigInteger.ONE)) >= 0);

            BigInteger x = a.modPow(d, n);
            if (x.equals(BigInteger.ONE) || x.equals(n.subtract(BigInteger.ONE)))
                continue;

            boolean composite = true;
            for (int r = 0; r < s - 1; r++) {
                x = x.modPow(BigInteger.TWO, n);
                if (x.equals(n.subtract(BigInteger.ONE))) {
                    composite = false;
                    break;
                }
            }
            if (composite)
                return false;
        }
        return true;
    }

    public static BigInteger generatePrime(int bits) {
        SecureRandom random = new SecureRandom();
        while (true) {
            BigInteger candidate = new BigInteger(bits, random)
                    .setBit(bits - 1)
                    .setBit(0);
            if (isProbablePrime(candidate, 20)) {
                return candidate;
            }
        }
    }

    public static BigInteger modInverse(BigInteger a, BigInteger m) {
        return a.modInverse(m);
    }

    public static class RSAKeyPair {
        BigInteger n, e, d, p, q;
        RSAKeyPair(BigInteger n, BigInteger e, BigInteger d, BigInteger p, BigInteger q) {
            this.n = n;
            this.e = e;
            this.d = d;
            this.p = p;
            this.q = q;
        }
    }

    public static RSAKeyPair generateRSAKeyPair(int bits, BigInteger e) {
        System.out.println("Line 1");
        System.out.println("Generating RSA Key Pair...");
        System.out.println();

        System.out.println("Line 2");
        System.out.println("Generating p and q...");
        System.out.println();

        int halfBits = bits / 2;
        BigInteger p = generatePrime(halfBits);
        BigInteger q = generatePrime(halfBits);
        while (p.equals(q)) {
            q = generatePrime(halfBits);
        }

        BigInteger n = p.multiply(q);
        BigInteger phi = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE));
        BigInteger d = modInverse(e, phi);

        System.out.println("Line 3");
        System.out.println("RSA Key Pair Generated Successfully!");
        System.out.println();

        return new RSAKeyPair(n, e, d, p, q);
    }

    public static void main(String[] args) {
        int keySize = 512; // you can change this to 1024
        BigInteger e = BigInteger.valueOf(65537);

        RSAKeyPair keyPair = generateRSAKeyPair(keySize, e);

        System.out.println("Public Key (n, e):");
        System.out.println("n = " + keyPair.n);
        System.out.println("e = " + keyPair.e);
        System.out.println();

        System.out.println("Private Key (d):");
        System.out.println("d = " + keyPair.d);
    }
}
